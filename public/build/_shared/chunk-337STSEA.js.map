{
  "version": 3,
  "sources": ["../../../node_modules/@artsy/fresnel/src/DynamicResponsive.tsx", "../../../node_modules/@artsy/fresnel/src/Utils.ts", "../../../node_modules/@artsy/fresnel/src/Breakpoints.ts", "../../../node_modules/@artsy/fresnel/src/Interactions.ts", "../../../node_modules/@artsy/fresnel/src/MediaQueries.ts", "../../../node_modules/@artsy/fresnel/src/Media.tsx", "../../../node_modules/@artsy/fresnel/src/index.tsx", "../../../app/components/common/Media.tsx"],
  "sourcesContent": ["/**\n * TODO: This is the deprecated runtime media-query component from Reaction.\n *       It can probably be simplified somewhat if we’re not going to be using\n *       it directly any longer.\n */\n\nimport React from \"react\"\n\n/** TODO */\nexport type MediaQueries<M extends string = string> = { [K in M]: string }\n\n/** TODO */\nexport interface MediaQueryMatchers {\n  [key: string]: MediaQueryList\n}\n\n/** TODO */\nexport type MediaQueryMatches<M extends string = string> = { [K in M]: boolean }\n\n/** TODO */\nexport interface ResponsiveProviderProps<M extends string> {\n  mediaQueries: MediaQueries<M>\n  initialMatchingMediaQueries?: M[]\n  children: React.ReactNode\n}\n\n/** TODO */\nexport interface ResponsiveProviderState {\n  mediaQueryMatchers?: MediaQueryMatchers\n  mediaQueryMatches: MediaQueryMatches\n}\n\nconst shallowEqual = (a: MediaQueryMatches, b: MediaQueryMatches) => {\n  for (const key in a) {\n    if (a[key] !== b[key]) return false\n  }\n  return true\n}\n\n/** TODO */\nexport function createResponsiveComponents<M extends string>() {\n  const ResponsiveContext = React.createContext({})\n  ResponsiveContext.displayName = \"Media.DynamicContext\"\n\n  const ResponsiveConsumer: React.FunctionComponent<\n    React.ConsumerProps<MediaQueryMatches<M>>\n  > = ResponsiveContext.Consumer as React.FunctionComponent<\n    React.ConsumerProps<any>\n  >\n\n  return {\n    Consumer: ResponsiveConsumer,\n    Provider: class ResponsiveProvider extends React.Component<\n      ResponsiveProviderProps<M>,\n      ResponsiveProviderState\n    > {\n      constructor(props: ResponsiveProviderProps<M>) {\n        super(props)\n        let mediaQueryMatchers: MediaQueryMatchers | undefined = undefined\n        let mediaQueryMatches: MediaQueryMatches\n\n        if (this.isSupportedEnvironment()) {\n          mediaQueryMatchers = this.setupMatchers(props.mediaQueries)\n          mediaQueryMatches = this.checkMatchers(mediaQueryMatchers)\n        } else {\n          mediaQueryMatches = Object.keys(props.mediaQueries).reduce(\n            (matches, key) => ({\n              ...matches,\n              [key]:\n                !!props.initialMatchingMediaQueries &&\n                props.initialMatchingMediaQueries.includes(key as M),\n            }),\n            {}\n          )\n        }\n\n        this.state = {\n          mediaQueryMatchers,\n          mediaQueryMatches,\n        }\n      }\n\n      isSupportedEnvironment = () => {\n        return (\n          typeof window !== \"undefined\" &&\n          typeof window.matchMedia !== \"undefined\"\n        )\n      }\n\n      /**\n       * Create an array of media matchers that can validate each media query\n       */\n      setupMatchers = (mediaQueries: MediaQueries): MediaQueryMatchers => {\n        return Object.keys(mediaQueries).reduce(\n          (matchers, key) => ({\n            ...matchers,\n            [key]: window.matchMedia(mediaQueries[key]),\n          }),\n          {}\n        )\n      }\n\n      /**\n       * Uses the matchers to build a map of the states of each media query\n       */\n      checkMatchers = (\n        mediaQueryMatchers: MediaQueryMatchers\n      ): MediaQueryMatches => {\n        return Object.keys(mediaQueryMatchers).reduce(\n          (matches, key) => ({\n            ...matches,\n            [key]: mediaQueryMatchers[key].matches,\n          }),\n          {}\n        )\n      }\n\n      /**\n       * The function that will be called any time a media query status changes\n       */\n      mediaQueryStatusChangedCallback = () => {\n        const mediaQueryMatches = this.checkMatchers(\n          this.state.mediaQueryMatchers!\n        )\n        this.setState({\n          mediaQueryMatches,\n        })\n      }\n\n      // Lifecycle methods\n\n      componentDidMount() {\n        if (this.state.mediaQueryMatchers) {\n          const { mediaQueryStatusChangedCallback } = this\n          Object.values(this.state.mediaQueryMatchers).forEach(matcher => {\n            matcher.addListener(mediaQueryStatusChangedCallback)\n          })\n        }\n      }\n\n      componentWillUnmount() {\n        if (this.state.mediaQueryMatchers) {\n          const { mediaQueryStatusChangedCallback } = this\n          Object.values(this.state.mediaQueryMatchers).forEach(matcher =>\n            matcher.removeListener(mediaQueryStatusChangedCallback)\n          )\n        }\n      }\n\n      shouldComponentUpdate(\n        nextProps: Readonly<ResponsiveProviderProps<M>>,\n        nextState: Readonly<ResponsiveProviderState>\n      ) {\n        if (!this.state.mediaQueryMatchers) return false\n        if (nextProps.children !== this.props.children) return true\n        if (\n          shallowEqual(\n            this.state.mediaQueryMatches,\n            nextState.mediaQueryMatches\n          )\n        ) {\n          return false\n        }\n        return true\n      }\n\n      render() {\n        return (\n          <ResponsiveContext.Provider value={this.state.mediaQueryMatches}>\n            {this.props.children}\n          </ResponsiveContext.Provider>\n        )\n      }\n    },\n  }\n}\n", "import { MediaBreakpointProps } from \"./Media\"\nimport { BreakpointConstraintKey } from \"./Breakpoints\"\n\n/**\n * Extracts the single breakpoint prop from the props object.\n */\nexport function propKey(breakpointProps: MediaBreakpointProps) {\n  return Object.keys(breakpointProps)[0] as BreakpointConstraintKey\n}\n\n/**\n * Returns the intersection of two arrays.\n */\nexport function intersection(\n  a1: ReadonlyArray<any>,\n  a2?: ReadonlyArray<any>\n): any[] {\n  return a2 ? a1.filter(element => a2.indexOf(element) >= 0) : [...a1]\n}\n\n/**\n * Generate a style rule for a given class name that will hide the element\n * when the given query matches.\n */\nexport function createRuleSet(className: string, query: string) {\n  return `@media ${query}{.${className}{display:none!important;}}`\n}\n\n/**\n * Given a list of strings, or string tuples, generates a class name.\n */\nexport function createClassName(\n  ...components: Array<string | [string, string]>\n) {\n  return [\n    \"fresnel\",\n    ...components.reduce(\n      (acc: string[], breakpoint) =>\n        Array.isArray(breakpoint)\n          ? [...acc, ...breakpoint]\n          : [...acc, breakpoint],\n      []\n    ),\n  ].join(\"-\")\n}\n\n/**\n * Returns an object with every values casted to integers.\n */\nexport function castBreakpointsToIntegers(breakpoints: {\n  [key: string]: number | string\n}): { [key: string]: number } {\n  const keys = Object.keys(breakpoints)\n\n  return keys.reduce(\n    (previous, current, currentIndex) => ({\n      ...previous,\n      [keys[currentIndex]]: Math.round(Number(breakpoints[current])),\n    }),\n    {}\n  )\n}\n\n/**\n * Use this function to memoize any function\n */\nexport function memoize<F extends (...args: any[]) => void>(func: F) {\n  const results = {}\n  return (...args) => {\n    const argsKey = JSON.stringify(args)\n    if (!results[argsKey]) {\n      results[argsKey] = func(...args)\n    }\n    return results[argsKey]\n  }\n}\n", "import { MediaBreakpointProps } from \"./Media\"\nimport { createRuleSet, createClassName } from \"./Utils\"\n\n/**\n * A union of possible breakpoint props.\n */\nexport type BreakpointConstraintKey = keyof MediaBreakpointProps\n\ntype ValueBreakpointPropsTuple<SizeValue, BreakpointKey> = [\n  SizeValue,\n  MediaBreakpointProps<BreakpointKey>\n]\n\ntype Tuple = [string, string]\n\nfunction breakpointKey(breakpoint: string | Tuple) {\n  return Array.isArray(breakpoint) ? breakpoint.join(\"-\") : breakpoint\n}\n\nexport enum BreakpointConstraint {\n  at = \"at\",\n  lessThan = \"lessThan\",\n  greaterThan = \"greaterThan\",\n  greaterThanOrEqual = \"greaterThanOrEqual\",\n  between = \"between\",\n}\n\n/**\n * Encapsulates all breakpoint data needed by the Media component. The data is\n * generated on initialization so no further runtime work is necessary.\n */\nexport class Breakpoints<BreakpointKey extends string> {\n  static validKeys() {\n    return [\n      BreakpointConstraint.at,\n      BreakpointConstraint.lessThan,\n      BreakpointConstraint.greaterThan,\n      BreakpointConstraint.greaterThanOrEqual,\n      BreakpointConstraint.between,\n    ]\n  }\n\n  private _sortedBreakpoints: ReadonlyArray<string>\n  private _breakpoints: Record<string, number>\n  private _mediaQueries: Record<BreakpointConstraint, Map<string, string>>\n\n  constructor(breakpoints: { [key: string]: number }) {\n    this._breakpoints = breakpoints\n\n    this._sortedBreakpoints = Object.keys(breakpoints)\n      .map(breakpoint => [breakpoint, breakpoints[breakpoint]])\n      .sort((a, b) => (a[1] < b[1] ? -1 : 1))\n      .map(breakpointAndValue => breakpointAndValue[0] as string)\n\n    // List of all possible and valid `between` combinations\n    const betweenCombinations = this._sortedBreakpoints\n      .slice(0, -1)\n      .reduce(\n        (acc: Tuple[], b1, i) => [\n          ...acc,\n          ...this._sortedBreakpoints.slice(i + 1).map(b2 => [b1, b2] as Tuple),\n        ],\n        []\n      )\n\n    this._mediaQueries = {\n      [BreakpointConstraint.at]: this._createBreakpointQueries(\n        BreakpointConstraint.at,\n        this._sortedBreakpoints\n      ),\n      [BreakpointConstraint.lessThan]: this._createBreakpointQueries(\n        BreakpointConstraint.lessThan,\n        this._sortedBreakpoints.slice(1)\n      ),\n      [BreakpointConstraint.greaterThan]: this._createBreakpointQueries(\n        BreakpointConstraint.greaterThan,\n        this._sortedBreakpoints.slice(0, -1)\n      ),\n      [BreakpointConstraint.greaterThanOrEqual]: this._createBreakpointQueries(\n        BreakpointConstraint.greaterThanOrEqual,\n        this._sortedBreakpoints\n      ),\n      [BreakpointConstraint.between]: this._createBreakpointQueries(\n        BreakpointConstraint.between,\n        betweenCombinations\n      ),\n    }\n  }\n\n  public get sortedBreakpoints() {\n    return this._sortedBreakpoints as BreakpointKey[]\n  }\n\n  public get dynamicResponsiveMediaQueries() {\n    return Array.from(\n      this._mediaQueries[BreakpointConstraint.at].entries()\n    ).reduce((acc, [k, v]) => ({ ...acc, [k]: v }), {})\n  }\n\n  public get largestBreakpoint() {\n    return this._sortedBreakpoints[this._sortedBreakpoints.length - 1]\n  }\n\n  public findBreakpointsForWidths = (\n    fromWidth: number,\n    throughWidth: number\n  ) => {\n    const fromBreakpoint = this.findBreakpointAtWidth(fromWidth)\n    if (!fromBreakpoint) {\n      return undefined\n    }\n    const throughBreakpoint = this.findBreakpointAtWidth(throughWidth)\n    if (!throughBreakpoint || fromBreakpoint === throughBreakpoint) {\n      return [fromBreakpoint] as BreakpointKey[]\n    } else {\n      return this._sortedBreakpoints.slice(\n        this._sortedBreakpoints.indexOf(fromBreakpoint),\n        this._sortedBreakpoints.indexOf(throughBreakpoint) + 1\n      ) as BreakpointKey[]\n    }\n  }\n\n  public findBreakpointAtWidth = (width: number) => {\n    return this._sortedBreakpoints.find((breakpoint, i) => {\n      const nextBreakpoint = this._sortedBreakpoints[i + 1]\n      if (nextBreakpoint) {\n        return (\n          width >= this._breakpoints[breakpoint] &&\n          width < this._breakpoints[nextBreakpoint]\n        )\n      } else {\n        return width >= this._breakpoints[breakpoint]\n      }\n    }) as BreakpointKey | undefined\n  }\n\n  public toVisibleAtBreakpointSet(breakpointProps: MediaBreakpointProps) {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const breakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === breakpointProps.lessThan\n      )\n      return this.sortedBreakpoints.slice(0, breakpointIndex)\n    } else if (breakpointProps.greaterThan) {\n      const breakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === breakpointProps.greaterThan\n      )\n      return this.sortedBreakpoints.slice(breakpointIndex + 1)\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const breakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === breakpointProps.greaterThanOrEqual\n      )\n      return this.sortedBreakpoints.slice(breakpointIndex)\n    } else if (breakpointProps.between) {\n      const between = breakpointProps.between\n      const fromBreakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === between[0]\n      )\n      const toBreakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === between[1]\n      )\n      return this.sortedBreakpoints.slice(\n        fromBreakpointIndex,\n        toBreakpointIndex\n      )\n    }\n    return []\n  }\n\n  public toRuleSets(keys = Breakpoints.validKeys()) {\n    const selectedMediaQueries = keys.reduce(\n      (mediaQueries, query) => {\n        mediaQueries[query] = this._mediaQueries[query]\n        return mediaQueries\n      },\n      {} as Record<BreakpointConstraint, Map<string, string>>\n    )\n\n    return Object.entries(selectedMediaQueries).reduce(\n      (acc: string[], [type, queries]) => {\n        queries.forEach((query, breakpoint) => {\n          // We need to invert the query, such that it matches when we want the\n          // element to be hidden.\n          acc.push(\n            createRuleSet(\n              createClassName(type, breakpoint),\n              `not all and ${query}`\n            )\n          )\n        })\n        return acc\n      },\n      []\n    )\n  }\n\n  public shouldRenderMediaQuery(\n    breakpointProps: MediaBreakpointProps,\n    onlyRenderAt: string[]\n  ): boolean {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const width = this._breakpoints[breakpointProps.lessThan]\n      const lowestAllowedWidth = Math.min(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return lowestAllowedWidth < width\n    } else if (breakpointProps.greaterThan) {\n      const width = this._breakpoints[\n        this._findNextBreakpoint(breakpointProps.greaterThan)\n      ]\n      const highestAllowedWidth = Math.max(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return highestAllowedWidth >= width\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const width = this._breakpoints[breakpointProps.greaterThanOrEqual]\n      const highestAllowedWidth = Math.max(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return highestAllowedWidth >= width\n    } else if (breakpointProps.between) {\n      // TODO: This is the only useful breakpoint to negate, but we’ll\n      //       we’ll see when/if we need it. We could then also decide\n      //       to add `oustide`.\n      const fromWidth = this._breakpoints[breakpointProps.between[0]]\n      const toWidth = this._breakpoints[breakpointProps.between[1]]\n      const allowedWidths = onlyRenderAt.map(\n        breakpoint => this._breakpoints[breakpoint]\n      )\n      return !(\n        Math.max(...allowedWidths) < fromWidth ||\n        Math.min(...allowedWidths) >= toWidth\n      )\n    }\n    return false\n  }\n\n  public valuesWithBreakpointProps = <SizeValue>(\n    values: SizeValue[]\n  ): ValueBreakpointPropsTuple<SizeValue, BreakpointKey>[] => {\n    type ValueBreakpoints = [SizeValue, string[]]\n    const max = values.length\n    const valueBreakpoints: ValueBreakpoints[] = []\n    let lastTuple: ValueBreakpoints\n    this._sortedBreakpoints.forEach((breakpoint, i) => {\n      const value = values[i]\n      if (i < max && (!lastTuple || lastTuple[0] !== value)) {\n        lastTuple = [value, [breakpoint]]\n        valueBreakpoints.push(lastTuple)\n      } else {\n        lastTuple[1].push(breakpoint)\n      }\n    })\n\n    return valueBreakpoints.map(([value, breakpoints], i) => {\n      const props: MediaBreakpointProps<any> = {}\n      if (i === valueBreakpoints.length - 1) {\n        props.greaterThanOrEqual = breakpoints[0]\n      } else if (breakpoints.length === 1) {\n        props.at = breakpoints[0]\n      } else {\n        // TODO: This is less than ideal, would be good to have a `through`\n        //       prop, which unlike `between` is inclusive.\n        props.between = [breakpoints[0], valueBreakpoints[i + 1][1][0]]\n      }\n      return [value, props] as ValueBreakpointPropsTuple<\n        SizeValue,\n        BreakpointKey\n      >\n    })\n  }\n\n  private _normalizeProps(\n    breakpointProps: MediaBreakpointProps\n  ): MediaBreakpointProps {\n    if (breakpointProps.at) {\n      const fromIndex = this._sortedBreakpoints.indexOf(breakpointProps.at)\n      const to = this._sortedBreakpoints[fromIndex + 1]\n      return to\n        ? { between: [breakpointProps.at, to] }\n        : { greaterThanOrEqual: breakpointProps.at }\n    }\n    return breakpointProps\n  }\n\n  private _createBreakpointQuery(\n    breakpointProps: MediaBreakpointProps\n  ): string {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const width = this._breakpoints[breakpointProps.lessThan]\n      return `(max-width:${width - 0.02}px)`\n    } else if (breakpointProps.greaterThan) {\n      const width = this._breakpoints[\n        this._findNextBreakpoint(breakpointProps.greaterThan)\n      ]\n      return `(min-width:${width}px)`\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const width = this._breakpoints[breakpointProps.greaterThanOrEqual]\n      return `(min-width:${width}px)`\n    } else if (breakpointProps.between) {\n      // TODO: This is the only useful breakpoint to negate, but we’ll\n      //       we’ll see when/if we need it. We could then also decide\n      //       to add `outside`.\n      const fromWidth = this._breakpoints[breakpointProps.between[0]]\n      const toWidth = this._breakpoints[breakpointProps.between[1]]\n      return `(min-width:${fromWidth}px) and (max-width:${toWidth - 0.02}px)`\n    }\n    throw new Error(\n      `Unexpected breakpoint props: ${JSON.stringify(breakpointProps)}`\n    )\n  }\n\n  private _createBreakpointQueries(\n    key: BreakpointConstraintKey,\n    forBreakpoints: ReadonlyArray<string | [string, string]>\n  ) {\n    return forBreakpoints.reduce<Map<string, string>>((map, breakpoint) => {\n      map.set(\n        breakpointKey(breakpoint),\n        this._createBreakpointQuery({\n          [key]: breakpoint,\n        })\n      )\n      return map\n    }, new Map())\n  }\n\n  private _findNextBreakpoint(breakpoint: string) {\n    const nextBreakpoint = this._sortedBreakpoints[\n      this._sortedBreakpoints.indexOf(breakpoint) + 1\n    ]\n    if (!nextBreakpoint) {\n      throw new Error(`There is no breakpoint larger than ${breakpoint}`)\n    }\n    return nextBreakpoint\n  }\n}\n", "import { createClassName, createRuleSet } from \"./Utils\"\n\nexport enum InteractionKey {\n  interaction = \"interaction\",\n}\n\n/**\n * Encapsulates all interaction data needed by the Media component. The data is\n * generated on initialization so no further runtime work is necessary.\n */\nexport class Interactions {\n  static validKeys() {\n    return [InteractionKey.interaction]\n  }\n\n  private _interactions: { [key: string]: string }\n\n  constructor(interactions: { [name: string]: string }) {\n    this._interactions = interactions\n  }\n\n  public toRuleSets() {\n    return Object.entries(this._interactions).reduce(\n      (acc: string[], [name, query]) => {\n        return [\n          ...acc,\n          createRuleSet(\n            createClassName(InteractionKey.interaction, name),\n            query\n          ),\n        ]\n      },\n      []\n    )\n  }\n\n  public get interactions() {\n    return Object.keys(this._interactions)\n  }\n\n  public get dynamicResponsiveMediaQueries() {\n    return Object.entries(this._interactions).reduce(\n      (acc, [name, query]) => ({ ...acc, [name]: query }),\n      {}\n    )\n  }\n\n  public shouldRenderMediaQuery(\n    interaction: string,\n    onlyMatch: string[]\n  ): boolean {\n    return !!(onlyMatch && onlyMatch.includes(interaction))\n  }\n}\n", "import { Breakpoints, BreakpointConstraint } from \"./Breakpoints\"\nimport { Interactions } from \"./Interactions\"\nimport { intersection } from \"./Utils\"\nimport { MediaBreakpointProps } from \"./Media\"\n\n/**\n * Encapsulates all interaction data (and breakpoint data in the superclass)\n * needed by the Media component. The data is generated on initialization so no\n * further runtime work is necessary.\n */\nexport class MediaQueries<B extends string> {\n  static validKeys() {\n    return [...Breakpoints.validKeys(), ...Interactions.validKeys()]\n  }\n\n  private _breakpoints: Breakpoints<B>\n  private _interactions: Interactions\n\n  constructor(\n    breakpoints: { [key: string]: number },\n    interactions: { [name: string]: string }\n  ) {\n    this._breakpoints = new Breakpoints(breakpoints)\n    this._interactions = new Interactions(interactions || {})\n  }\n\n  public get breakpoints() {\n    return this._breakpoints\n  }\n\n  public toStyle = (breakpointKeys?: BreakpointConstraint[]) => {\n    return [\n      // Don’t add any size to the layout\n      \".fresnel-container{margin:0;padding:0;}\",\n      ...this._breakpoints.toRuleSets(breakpointKeys),\n      ...this._interactions.toRuleSets(),\n    ].join(\"\\n\")\n  }\n\n  public get mediaQueryTypes() {\n    return [\n      ...this._breakpoints.sortedBreakpoints,\n      ...this._interactions.interactions,\n    ]\n  }\n\n  public get dynamicResponsiveMediaQueries() {\n    return {\n      ...this._breakpoints.dynamicResponsiveMediaQueries,\n      ...this._interactions.dynamicResponsiveMediaQueries,\n    }\n  }\n\n  public shouldRenderMediaQuery(\n    mediaQueryProps: { interaction?: string } & MediaBreakpointProps,\n    onlyMatch: string[]\n  ): boolean {\n    const { interaction, ...breakpointProps } = mediaQueryProps\n    if (interaction) {\n      return this._interactions.shouldRenderMediaQuery(interaction, onlyMatch)\n    }\n    // Remove any interaction possibilities from the list.\n    const onlyMatchBreakpoints = intersection(\n      onlyMatch,\n      this._breakpoints.sortedBreakpoints\n    )\n    return this._breakpoints.shouldRenderMediaQuery(\n      breakpointProps,\n      onlyMatchBreakpoints\n    )\n  }\n}\n", "// tslint:disable:jsdoc-format\n\nimport React, { CSSProperties } from \"react\"\nimport { createResponsiveComponents } from \"./DynamicResponsive\"\nimport { MediaQueries } from \"./MediaQueries\"\nimport {\n  intersection,\n  propKey,\n  createClassName,\n  castBreakpointsToIntegers,\n  memoize,\n} from \"./Utils\"\nimport { BreakpointConstraint } from \"./Breakpoints\"\n\n/**\n * A render prop that can be used to render a different container element than\n * the default `div`.\n *\n * @see {@link MediaProps.children}.\n */\nexport type RenderProp = (\n  className: string,\n  renderChildren: boolean\n) => React.ReactNode\n\n// TODO: All of these props should be mutually exclusive. Using a union should\n//       probably be made possible by https://github.com/Microsoft/TypeScript/pull/27408.\nexport interface MediaBreakpointProps<BreakpointKey = string> {\n  /**\n   * Children will only be shown if the viewport matches the specified\n   * breakpoint. That is, a viewport width that’s higher than the configured\n   * breakpoint value, but lower than the value of the next breakpoint, if any\n   * larger breakpoints exist at all.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width between 0 and 768\n     <Media at=\"xs\">ohai</Media>\n\n     // Matches a viewport that has a width between 768 and 1024\n     <Media at=\"sm\">ohai</Media>\n\n     // Matches a viewport that has a width over 1024\n     <Media at=\"md\">ohai</Media>\n     ```\n   *\n   */\n  at?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is smaller than the specified\n   * breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n    // Matches a viewport that has a width from 0 to 767\n     <Media lessThan=\"sm\">ohai</Media>\n\n     // Matches a viewport that has a width from 0 to 1023\n     <Media lessThan=\"md\">ohai</Media>\n     ```\n   *\n   */\n  lessThan?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is greater than the specified\n   * breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width from 768 to infinity\n     <Media greaterThan=\"xs\">ohai</Media>\n\n     // Matches a viewport that has a width from 1024 to infinity\n     <Media greaterThan=\"sm\">ohai</Media>\n     ```\n   *\n   */\n  greaterThan?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is greater or equal to the\n   * specified breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width from 0 to infinity\n     <Media greaterThanOrEqual=\"xs\">ohai</Media>\n\n     // Matches a viewport that has a width from 768 to infinity\n     <Media greaterThanOrEqual=\"sm\">ohai</Media>\n\n     // Matches a viewport that has a width from 1024 to infinity\n     <Media greaterThanOrEqual=\"md\">ohai</Media>\n     ```\n   *\n   */\n  greaterThanOrEqual?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is between the specified\n   * breakpoints. That is, a viewport width that’s higher than or equal to the\n   * small breakpoint value, but lower than the value of the large breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width from 0 to 767\n     <Media between={[\"xs\", \"sm\"]}>ohai</Media>\n\n     // Matches a viewport that has a width from 0 to 1023\n     <Media between={[\"xs\", \"md\"]}>ohai</Media>\n     ```\n   *\n   */\n  between?: [BreakpointKey, BreakpointKey]\n}\n\nexport interface MediaProps<BreakpointKey, Interaction>\n  extends MediaBreakpointProps<BreakpointKey> {\n  /**\n   * Children will only be shown if the interaction query matches.\n   *\n   * @example\n\n     ```tsx\n     // With interactions defined like these\n     { hover: \"(hover: hover)\" }\n\n     // Matches an input device that is capable of hovering\n     <Media interaction=\"hover\">ohai</Media>\n     ```\n   */\n  interaction?: Interaction\n\n  /**\n   * The component(s) that should conditionally be shown, depending on the media\n   * query matching.\n   *\n   * In case a different element is preferred, a render prop can be provided\n   * that receives the class-name it should use to have the media query styling\n   * applied.\n   *\n   * Additionally, the render prop receives a boolean that indicates wether or\n   * not its children should be rendered, which will be `false` if the media\n   * query is not included in the `onlyMatch` list. Use this flag if your\n   * component’s children may be expensive to render and you want to avoid any\n   * unnecessary work.\n   * (@see {@link MediaContextProviderProps.onlyMatch} for details)\n   *\n   * @example\n   *\n     ```tsx\n     const Component = () => (\n       <Media greaterThan=\"xs\">\n         {(className, renderChildren) => (\n           <span className={className}>\n             {renderChildren && \"ohai\"}\n           </span>\n         )}\n       </Media>\n     )\n     ```\n   *\n   */\n  children: React.ReactNode | RenderProp\n\n  /**\n   * Additional classNames to passed down and applied to Media container\n   */\n  className?: string\n\n  /**\n   * Additional styles to passed down and applied to Media container\n   */\n  style?: CSSProperties\n}\n\nexport interface MediaContextProviderProps<M> {\n  /**\n   * This list of breakpoints and interactions can be used to limit the rendered\n   * output to these.\n   *\n   * For instance, when a server knows for some user-agents that certain\n   * breakpoints will never apply, omitting them altogether will lower the\n   * rendered byte size.\n   */\n  onlyMatch?: M[]\n\n  /**\n   * Disables usage of browser MediaQuery API to only render at the current\n   * breakpoint.\n   *\n   * Use this with caution, as disabling this means React components for all\n   * breakpoints will be mounted client-side and all associated life-cycle hooks\n   * will be triggered, which could lead to unintended side-effects.\n   */\n  disableDynamicMediaQueries?: boolean\n}\n\nexport interface CreateMediaConfig {\n  /**\n   * The breakpoint definitions for your application. Width definitions should\n   * start at 0.\n   *\n   * @see {@link createMedia}\n   */\n  breakpoints: { [key: string]: number | string }\n\n  /**\n   * The interaction definitions for your application.\n   */\n  interactions?: { [key: string]: string }\n}\n\nexport interface CreateMediaResults<BreakpointKey, Interactions> {\n  /**\n   * The React component that you use throughout your application.\n   *\n   * @see {@link MediaBreakpointProps}\n   */\n  Media: React.ComponentType<MediaProps<BreakpointKey, Interactions>>\n\n  /**\n   * The React Context provider component that you use to constrain rendering of\n   * breakpoints to a set list and to enable client-side dynamic constraining.\n   *\n   * @see {@link MediaContextProviderProps}\n   */\n  MediaContextProvider: React.ComponentType<\n    MediaContextProviderProps<BreakpointKey | Interactions> & {\n      children: React.ReactNode\n    }\n  >\n\n  /**\n   * Generates a set of CSS rules that you should include in your application’s\n   * styling to enable the hiding behaviour of your `Media` component uses.\n   */\n  createMediaStyle(breakpointKeys?: BreakpointConstraint[]): string\n\n  /**\n   * A list of your application’s breakpoints sorted from small to large.\n   */\n  SortedBreakpoints: BreakpointKey[]\n\n  /**\n   * Creates a list of your application’s breakpoints that support the given\n   * widths and everything in between.\n   */\n  findBreakpointsForWidths(\n    fromWidth: number,\n    throughWidth: number\n  ): BreakpointKey[] | undefined\n\n  /**\n   * Finds the breakpoint that matches the given width.\n   */\n  findBreakpointAtWidth(width: number): BreakpointKey | undefined\n\n  /**\n   * Maps a list of values for various breakpoints to props that can be used\n   * with the `Media` component.\n   *\n   * The values map to corresponding indices in the sorted breakpoints array. If\n   * less values are specified than the number of breakpoints your application\n   * has, the last value will be applied to all subsequent breakpoints.\n   */\n  valuesWithBreakpointProps<SizeValue>(\n    values: SizeValue[]\n  ): [SizeValue, MediaBreakpointProps<BreakpointKey>][]\n}\n\n/**\n * This is used to generate a Media component, its context provider, and CSS\n * rules based on your application’s breakpoints and interactions.\n *\n * Note that the interaction queries are entirely up to you to define and they\n * should be written in such a way that they match when you want the element to\n * be hidden.\n *\n * @example\n *\n   ```tsx\n   const MyAppMedia = createMedia({\n     breakpoints: {\n       xs: 0,\n       sm: 768,\n       md: 900\n       lg: 1024,\n       xl: 1192,\n     },\n     interactions: {\n       hover: `not all and (hover:hover)`\n     },\n   })\n\n   export const Media = MyAppMedia.Media\n   export const MediaContextProvider = MyAppMedia.MediaContextProvider\n   export const createMediaStyle = MyAppMedia.createMediaStyle\n   ```\n *\n */\nexport function createMedia<\n  MediaConfig extends CreateMediaConfig,\n  BreakpointKey extends keyof MediaConfig[\"breakpoints\"],\n  Interaction extends keyof MediaConfig[\"interactions\"]\n>(config: MediaConfig): CreateMediaResults<BreakpointKey, Interaction> {\n  const breakpoints = castBreakpointsToIntegers(config.breakpoints)\n\n  const mediaQueries = new MediaQueries<BreakpointKey>(\n    breakpoints,\n    config.interactions || {}\n  )\n\n  const DynamicResponsive = createResponsiveComponents()\n\n  const MediaContext = React.createContext<\n    MediaContextProviderProps<BreakpointKey | Interaction>\n  >({})\n  MediaContext.displayName = \"Media.Context\"\n\n  const MediaParentContext = React.createContext<{\n    hasParentMedia: boolean\n    breakpointProps: MediaBreakpointProps<BreakpointKey>\n  }>({ hasParentMedia: false, breakpointProps: {} })\n  MediaContext.displayName = \"MediaParent.Context\"\n\n  const getMediaContextValue = memoize(onlyMatch => ({\n    onlyMatch,\n  }))\n\n  const MediaContextProvider: React.FunctionComponent<\n    MediaContextProviderProps<BreakpointKey | Interaction> & {\n      children?: React.ReactNode\n    }\n  > = ({ disableDynamicMediaQueries, onlyMatch, children }) => {\n    if (disableDynamicMediaQueries) {\n      const MediaContextValue = getMediaContextValue(onlyMatch)\n\n      return (\n        <MediaContext.Provider value={MediaContextValue}>\n          {children}\n        </MediaContext.Provider>\n      )\n    } else {\n      return (\n        <DynamicResponsive.Provider\n          mediaQueries={mediaQueries.dynamicResponsiveMediaQueries}\n          initialMatchingMediaQueries={intersection(\n            mediaQueries.mediaQueryTypes,\n            onlyMatch\n          )}\n        >\n          <DynamicResponsive.Consumer>\n            {matches => {\n              const matchingMediaQueries = Object.keys(matches).filter(\n                key => matches[key]\n              )\n\n              const MediaContextValue = getMediaContextValue(\n                intersection(matchingMediaQueries, onlyMatch)\n              )\n\n              return (\n                <MediaContext.Provider value={MediaContextValue}>\n                  {children}\n                </MediaContext.Provider>\n              )\n            }}\n          </DynamicResponsive.Consumer>\n        </DynamicResponsive.Provider>\n      )\n    }\n  }\n\n  const Media = class extends React.Component<\n    MediaProps<BreakpointKey, Interaction>\n  > {\n    constructor(props) {\n      super(props)\n      validateProps(props)\n    }\n\n    static defaultProps = {\n      className: \"\",\n      style: {},\n    }\n\n    static contextType = MediaParentContext\n\n    getMediaParentContextValue = memoize(\n      (breakpointProps: MediaBreakpointProps<BreakpointKey>) => ({\n        hasParentMedia: true,\n        breakpointProps,\n      })\n    )\n\n    render() {\n      const props = this.props\n      const {\n        children,\n        className: passedClassName,\n        style,\n        interaction,\n        ...breakpointProps\n      } = props\n      const mediaParentContextValue = this.getMediaParentContextValue(\n        breakpointProps\n      )\n\n      return (\n        <MediaParentContext.Consumer>\n          {mediaParentContext => {\n            return (\n              <MediaParentContext.Provider value={mediaParentContextValue}>\n                <MediaContext.Consumer>\n                  {({ onlyMatch } = {}) => {\n                    let className: string | null\n                    if (props.interaction) {\n                      className = createClassName(\n                        \"interaction\",\n                        props.interaction\n                      )\n                    } else {\n                      if (props.at) {\n                        const largestBreakpoint =\n                          mediaQueries.breakpoints.largestBreakpoint\n                        if (props.at === largestBreakpoint) {\n                          // TODO: We should look into making React’s __DEV__ available\n                          //       and have webpack completely compile these away.\n                          let ownerName = null\n                          try {\n                            const owner = (this as any)._reactInternalFiber\n                              ._debugOwner.type\n                            ownerName = owner.displayName || owner.name\n                          } catch (err) {\n                            // no-op\n                          }\n\n                          console.warn(\n                            \"[@artsy/fresnel] \" +\n                              \"`at` is being used with the largest breakpoint. \" +\n                              \"Consider using `<Media greaterThanOrEqual=\" +\n                              `\"${largestBreakpoint}\">\\` to account for future ` +\n                              `breakpoint definitions outside of this range.${\n                                ownerName\n                                  ? ` It is being used in the ${ownerName} component.`\n                                  : \"\"\n                              }`\n                          )\n                        }\n                      }\n\n                      const type = propKey(breakpointProps)\n                      const breakpoint = breakpointProps[type]!\n                      className = createClassName(type, breakpoint)\n                    }\n\n                    const doesMatchParent =\n                      !mediaParentContext.hasParentMedia ||\n                      intersection(\n                        mediaQueries.breakpoints.toVisibleAtBreakpointSet(\n                          mediaParentContext.breakpointProps\n                        ),\n                        mediaQueries.breakpoints.toVisibleAtBreakpointSet(\n                          breakpointProps\n                        )\n                      ).length > 0\n                    const renderChildren =\n                      doesMatchParent &&\n                      (onlyMatch === undefined ||\n                        mediaQueries.shouldRenderMediaQuery(\n                          { ...breakpointProps, interaction },\n                          onlyMatch\n                        ))\n\n                    if (props.children instanceof Function) {\n                      return props.children(className, renderChildren)\n                    } else {\n                      return (\n                        <div\n                          className={`fresnel-container ${className} ${passedClassName}`}\n                          style={style}\n                          suppressHydrationWarning={!renderChildren}\n                        >\n                          {renderChildren ? props.children : null}\n                        </div>\n                      )\n                    }\n                  }}\n                </MediaContext.Consumer>\n              </MediaParentContext.Provider>\n            )\n          }}\n        </MediaParentContext.Consumer>\n      )\n    }\n  }\n\n  return {\n    Media,\n    MediaContextProvider,\n    createMediaStyle: mediaQueries.toStyle,\n    SortedBreakpoints: [...mediaQueries.breakpoints.sortedBreakpoints],\n    findBreakpointAtWidth: mediaQueries.breakpoints.findBreakpointAtWidth,\n    findBreakpointsForWidths: mediaQueries.breakpoints.findBreakpointsForWidths,\n    valuesWithBreakpointProps:\n      mediaQueries.breakpoints.valuesWithBreakpointProps,\n  }\n}\n\nconst MutuallyExclusiveProps: string[] = MediaQueries.validKeys()\n\nfunction validateProps(props) {\n  const selectedProps = Object.keys(props).filter(prop =>\n    MutuallyExclusiveProps.includes(prop)\n  )\n  if (selectedProps.length < 1) {\n    throw new Error(`1 of ${MutuallyExclusiveProps.join(\", \")} is required.`)\n  } else if (selectedProps.length > 1) {\n    throw new Error(\n      `Only 1 of ${selectedProps.join(\", \")} is allowed at a time.`\n    )\n  }\n}\n", "export { createMedia } from \"./Media\"\nexport { BreakpointConstraint as BreakpointKey } from \"./Breakpoints\"\n", "import { createMedia } from \"@artsy/fresnel\";\n\nconst ExampleAppMedia = createMedia({\n  interactions: {\n    landscape: \"not all and (orientation: landscape)\",\n    portrait: \"not all and (orientation: portrait)\",\n    hover: \"(hover: hover)\",\n    notHover: \"(hover: none)\",\n  },\n  breakpoints: {\n    sm: 0,\n    md: 768,\n    lg: 1024,\n    xl: 1192,\n  },\n});\n\n// Make styles for injection into the header of the page\nexport const mediaStyles = ExampleAppMedia.createMediaStyle();\n\nexport const { Media, MediaContextProvider } = ExampleAppMedia;\n"],
  "mappings": "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",
  "names": ["shallowEqual", "a", "b", "key", "createResponsiveComponents", "ResponsiveContext", "React", "createContext", "displayName", "ResponsiveConsumer", "Consumer", "Provider", "props", "window", "matchMedia", "mediaQueries", "Object", "keys", "reduce", "matchers", "mediaQueryMatchers", "matches", "mediaQueryMatches", "checkMatchers", "state", "setState", "undefined", "isSupportedEnvironment", "setupMatchers", "initialMatchingMediaQueries", "includes", "mediaQueryStatusChangedCallback", "values", "forEach", "matcher", "addListener", "removeListener", "nextProps", "nextState", "children", "Component", "propKey", "breakpointProps", "Object", "keys", "intersection", "a1", "a2", "filter", "element", "indexOf", "createRuleSet", "className", "query", "createClassName", "components", "reduce", "acc", "breakpoint", "Array", "isArray", "join", "castBreakpointsToIntegers", "breakpoints", "previous", "current", "currentIndex", "Math", "round", "Number", "memoize", "func", "results", "args", "argsKey", "JSON", "stringify", "breakpointKey", "breakpoint", "Array", "isArray", "join", "BreakpointConstraint", "Breakpoints", "at", "lessThan", "greaterThan", "greaterThanOrEqual", "between", "breakpoints", "fromWidth", "throughWidth", "fromBreakpoint", "findBreakpointAtWidth", "undefined", "throughBreakpoint", "_sortedBreakpoints", "slice", "indexOf", "width", "find", "i", "nextBreakpoint", "_breakpoints", "values", "max", "length", "valueBreakpoints", "lastTuple", "forEach", "value", "push", "map", "props", "Object", "keys", "sort", "a", "b", "breakpointAndValue", "betweenCombinations", "reduce", "acc", "b1", "b2", "_mediaQueries", "_createBreakpointQueries", "breakpointProps", "_normalizeProps", "breakpointIndex", "sortedBreakpoints", "findIndex", "bp", "fromBreakpointIndex", "toBreakpointIndex", "validKeys", "selectedMediaQueries", "mediaQueries", "query", "entries", "type", "queries", "onlyRenderAt", "lowestAllowedWidth", "Math", "min", "_findNextBreakpoint", "highestAllowedWidth", "toWidth", "allowedWidths", "fromIndex", "to", "Error", "JSON", "stringify", "key", "forBreakpoints", "set", "_createBreakpointQuery", "Map", "from", "k", "v", "InteractionKey", "Interactions", "interaction", "interactions", "_interactions", "Object", "entries", "reduce", "acc", "name", "query", "onlyMatch", "includes", "keys", "MediaQueries", "Breakpoints", "validKeys", "Interactions", "breakpoints", "interactions", "breakpointKeys", "_breakpoints", "toRuleSets", "_interactions", "join", "mediaQueryProps", "onlyMatch", "interaction", "breakpointProps", "shouldRenderMediaQuery", "onlyMatchBreakpoints", "sortedBreakpoints", "dynamicResponsiveMediaQueries", "createMedia", "config", "breakpoints", "mediaQueries", "MediaQueries", "interactions", "DynamicResponsive", "MediaContext", "React", "createContext", "displayName", "MediaParentContext", "hasParentMedia", "breakpointProps", "getMediaContextValue", "onlyMatch", "MediaContextProvider", "disableDynamicMediaQueries", "children", "MediaContextValue", "dynamicResponsiveMediaQueries", "mediaQueryTypes", "matches", "matchingMediaQueries", "Object", "keys", "filter", "key", "Media", "props", "validateProps", "passedClassName", "className", "style", "interaction", "mediaParentContextValue", "getMediaParentContextValue", "mediaParentContext", "at", "largestBreakpoint", "ownerName", "owner", "_reactInternalFiber", "_debugOwner", "type", "name", "err", "console", "warn", "breakpoint", "doesMatchParent", "toVisibleAtBreakpointSet", "length", "renderChildren", "undefined", "shouldRenderMediaQuery", "Function", "Component", "createMediaStyle", "toStyle", "SortedBreakpoints", "sortedBreakpoints", "findBreakpointAtWidth", "findBreakpointsForWidths", "valuesWithBreakpointProps", "MutuallyExclusiveProps", "validKeys", "selectedProps", "prop", "includes", "Error", "join"]
}
